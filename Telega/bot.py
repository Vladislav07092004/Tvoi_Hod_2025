from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.utils import executor
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text, DateTime
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker
import datetime
import logging
import os
logging.basicConfig()
logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)


# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö SQLite
DATABASE_URL = "sqlite:///database.db"
Base = declarative_base()
engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
session = SessionLocal()

# –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    telegram_id = Column(String, unique=True, index=True)
    full_name = Column(String)
    role = Column(String)  # "student" –∏–ª–∏ "teacher"
    group_id = Column(Integer, ForeignKey("groups.id"), nullable=True)

class Group(Base):
    __tablename__ = "groups"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True)
    password = Column(String)

class Task(Base):
    __tablename__ = "tasks"
    id = Column(Integer, primary_key=True, index=True)
    group_id = Column(Integer, ForeignKey("groups.id"))
    name = Column(String)
    description = Column(Text)
    deadline = Column(DateTime)

# –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≥—Ä—É–ø–ø—ã
class WatchGroup(StatesGroup):
    waiting_for_group_id = State()

# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
Base.metadata.create_all(bind=engine)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Telegram-–±–æ—Ç–∞
API_TOKEN = "7235928823:AAHS3cfYTA3S9IlpdGub8284WPdg5shbTzE"
bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

class CreateGroup(StatesGroup):
    waiting_for_group_name = State()

class CreateTask(StatesGroup):
    waiting_for_group_id = State()
    waiting_for_task_name = State()
    waiting_for_task_description = State()
    waiting_for_task_deadline = State()

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message_handler(commands=['start'])
async def start_command(message: types.Message):
    user = session.query(User).filter_by(telegram_id=str(message.from_user.id)).first()
    if user:
        await message.reply(f"–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ {user.role}.")
    else:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add("–°—Ç—É–¥–µ–Ω—Ç", "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å")
        await message.reply("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É —Ä–æ–ª—å:", reply_markup=markup)

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@dp.message_handler(lambda message: message.text in ["–°—Ç—É–¥–µ–Ω—Ç", "–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å"])
async def register_user(message: types.Message):
    role = "student" if message.text == "–°—Ç—É–¥–µ–Ω—Ç" else "teacher"
    user = User(telegram_id=str(message.from_user.id), full_name=message.from_user.full_name, role=role)
    session.add(user)
    session.commit()
    if role == "teacher":
        await message.reply("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /create_group –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä—É–ø–ø—ã.")
    else:
        await message.reply("–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ —Å—Ç—É–¥–µ–Ω—Ç! –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã:")

# –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã
@dp.message_handler(commands=['create_group'])
async def create_group(message: types.Message):
    user = session.query(User).filter_by(telegram_id=str(message.from_user.id)).first()
    if not user or user.role != "teacher":
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π.")
        return
    await message.reply("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã:")
    await CreateGroup.waiting_for_group_name.set()

@dp.message_handler(state=CreateGroup.waiting_for_group_name, content_types=types.ContentTypes.TEXT)
async def save_group_name(message: types.Message, state: FSMContext):
    group_name = message.text.strip()
    password = os.urandom(4).hex()
    group = Group(name=group_name, password=password)
    session.add(group)
    session.commit()
    await message.reply(f"–ì—Ä—É–ø–ø–∞ '{group_name}' —Å–æ–∑–¥–∞–Ω–∞. –ü–∞—Ä–æ–ª—å –¥–ª—è —É—á–µ–Ω–∏–∫–æ–≤: {password}")
    await state.finish()

# –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—á–µ–Ω–∏–∫–∞ –∫ –≥—Ä—É–ø–ø–µ
@dp.message_handler(lambda message: not message.text.startswith("–ì—Ä—É–ø–ø–∞: ") and len(message.text) == 8)
async def join_group(message: types.Message):
    user = session.query(User).filter_by(telegram_id=str(message.from_user.id)).first()
    if not user or user.role != "student":
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤.")
        return
    group = session.query(Group).filter_by(password=message.text).first()
    if group:
        user.group_id = group.id
        session.commit()
        await message.reply(f"–í—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ –≥—Ä—É–ø–ø–µ '{group.name}'.")
    else:
        await message.reply("–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –≥—Ä—É–ø–ø—ã.")

# –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
@dp.message_handler(commands=['create_task'])
async def create_task(message: types.Message):
    user = session.query(User).filter_by(telegram_id=str(message.from_user.id)).first()
    if not user or user.role != "teacher":
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π.")
        return
    groups = session.query(Group).all()
    if not groups:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –≥—Ä—É–ø–ø—É —Å –ø–æ–º–æ—â—å—é /create_group.")
        return
    group_list = "\n".join([f"{g.id}: {g.name}" for g in groups])
    await message.reply(f"–í—ã–±–µ—Ä–∏—Ç–µ ID –≥—Ä—É–ø–ø—ã –¥–ª—è –∑–∞–¥–∞–Ω–∏—è:\n{group_list}")
    await CreateTask.waiting_for_group_id.set()

@dp.message_handler(state=CreateTask.waiting_for_group_id, content_types=types.ContentTypes.TEXT)
async def set_task_group(message: types.Message, state: FSMContext):
    group_id = int(message.text)
    group = session.query(Group).filter_by(id=group_id).first()
    if not group:
        await message.reply("–ì—Ä—É–ø–ø–∞ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return
    await state.update_data(group_id=group_id)
    await message.reply("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:")
    await CreateTask.waiting_for_task_name.set()

@dp.message_handler(state=CreateTask.waiting_for_task_name, content_types=types.ContentTypes.TEXT)
async def set_task_name(message: types.Message, state: FSMContext):
    await state.update_data(task_name=message.text.strip())
    await message.reply("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:")
    await CreateTask.waiting_for_task_description.set()

@dp.message_handler(state=CreateTask.waiting_for_task_description, content_types=types.ContentTypes.TEXT)
async def set_task_description(message: types.Message, state: FSMContext):
    await state.update_data(task_description=message.text.strip())
    await message.reply("–í–≤–µ–¥–∏—Ç–µ –¥–µ–¥–ª–∞–π–Ω –∑–∞–¥–∞–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD HH:MM:")
    await CreateTask.waiting_for_task_deadline.set()

@dp.message_handler(state=CreateTask.waiting_for_task_deadline, content_types=types.ContentTypes.TEXT)
async def save_task(message: types.Message, state: FSMContext):
    try:
        deadline = datetime.datetime.strptime(message.text.strip(), "%Y-%m-%d %H:%M")
        data = await state.get_data()
        task = Task(
            group_id=data["group_id"],
            name=data["task_name"],
            description=data["task_description"],
            deadline=deadline
        )
        session.add(task)
        session.commit()
        await message.reply(f"–ó–∞–¥–∞–Ω–∏–µ '{task.name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–æ.")
        await state.finish()
    except ValueError:
        await message.reply("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ (—Ñ–æ—Ä–º–∞—Ç: YYYY-MM-DD HH:MM).")

@dp.message_handler(commands=['help'])
async def help_command(message: types.Message):
    help_text = """
üìö **–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥:**

üë®‚Äçüè´ **–î–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π:**
- `/create_group` ‚Äî —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É.
- `/create_task` ‚Äî —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã.
- `/watchgroup` ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≥—Ä—É–ø–ø—ã.
- `/report` ‚Äî –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ —É—á–µ–Ω–∏–∫–æ–≤.

üë®‚Äçüéì **–î–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤:**
- –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –≥—Ä—É–ø–ø—ã, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è.
- `/submit` ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è.

‚ÑπÔ∏è **–û–±—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:**
- `/help` ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
- `/start` ‚Äî –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º.

üí° –ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.
    """
    await message.reply(help_text, parse_mode="Markdown")


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /watchgroup
@dp.message_handler(commands=['watchgroup'])
async def watch_group(message: types.Message):
    user = session.query(User).filter_by(telegram_id=str(message.from_user.id)).first()
    if not user or user.role != "teacher":
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π.")
        return

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –≥—Ä—É–ø–ø, —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º
    groups = session.query(Group).all()
    if not groups:
        await message.reply("–í—ã –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–ª–∏ –Ω–∏ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /create_group, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –≥—Ä—É–ø–ø—É.")
        return

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—é
    group_list = "\n".join([f"{group.id}: {group.name}" for group in groups])
    await message.reply(f"–í—ã–±–µ—Ä–∏—Ç–µ ID –≥—Ä—É–ø–ø—ã, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –µ—ë —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:\n{group_list}")
    await WatchGroup.waiting_for_group_id.set()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –≥—Ä—É–ø–ø—ã
@dp.message_handler(state=WatchGroup.waiting_for_group_id, content_types=types.ContentTypes.TEXT)
async def show_group_members(message: types.Message, state: FSMContext):
    try:
        group_id = int(message.text.strip())
        group = session.query(Group).filter_by(id=group_id).first()

        if not group:
            await message.reply("–ì—Ä—É–ø–ø–∞ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
            return

        # –ü–æ–ª—É—á–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≥—Ä—É–ø–ø—ã
        members = session.query(User).filter_by(group_id=group.id).all()
        if not members:
            await message.reply(f"–í –≥—Ä—É–ø–ø–µ '{group.name}' –ø–æ–∫–∞ –Ω–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.")
        else:
            member_list = "\n".join([f"- {member.full_name}" for member in members])
            await message.reply(f"–£—á–∞—Å—Ç–Ω–∏–∫–∏ –≥—Ä—É–ø–ø—ã '{group.name}':\n{member_list}")

    except ValueError:
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –≥—Ä—É–ø–ø—ã (—á–∏—Å–ª–æ).")
    finally:
        # –ó–∞–≤–µ—Ä—à–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        await state.finish()


@dp.message_handler(lambda message: message.text.isdigit())
async def set_task_group(message: types.Message):
    group_id = int(message.text)
    group = session.query(Group).filter_by(id=group_id).first()
    if group:
        await message.reply("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:")
    else:
        await message.reply("–ì—Ä—É–ø–ø–∞ —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
